\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{url}
\graphicspath{ {pictures/} }
\begin{document}
\begin{center}
	Конспект лекций по операционным системам.
\end{center}
\section*{Базовые определения}
Прикладное ПО - это программы, выполняющие задачи, требуемые пользователю\\
Системное ПО - это программы, способствующие функционированию прикладных программ и упрощающие их разработку\\
Системное ПО - это операционные системы, драйверы и фреймворки\\
Драйвер - программа, управляющая работой периферийного устройства\\
Операционная система - это программа, обеспечивающая среду выполнения для других программ и облегчающая им доступ к устройствам, составляющим компьютер, процессору, жёсткому диску и т.д.  \\
Фреймворк - это программная среда специального назначения, используемая для того, чтобы упростить написание программ и облегчить объединение отдельных программных компонентов.\\
\section*{Услуги, предоставляемые ОС}
Упрощают использование аппаратных средств. Создаваемая ими виртуальная машина заметно отличается от реальной. ОС изолируют пользователей от аппаратной части компьютеров.\\
ОС обеспечивает распределение вычислительных ресурсов между программами.\\
Управляет файлами и папками. Для упрощения работы пользователей создаётся файловая система.\\
Предоставляет пользователю интерфейс для взаимодействия с программами и компьютером.\\
\section*{Интерфейс}
Интерфейс - набор средств, используемые для взаимодействия двух систем.\\
\section*{Типы интерфейсов}
Графический интерфейс. Управление осуществляется путём нажатия на различные виды кнопок, которые изображены на экране. \\
Интерфейс командной строки. Управление осуществляется путём набора текстовых команд.\\
Программный интерфейс. Через программный интерфейс программы взаимодействуют друг с другом. API - Application Programming Interface.\\
Голосовой интерфейс - команды даются с помощью голоса, речи.\\
Жестовый интерес - управление с помощью жестов: сенсорный экран, тачпад, джойстик, руль \\
Нейрокомпьютерный интерфейс - обмен данными между человеческим мозгом и электронным устройством осуществляется с помощью биологической обратной связи и встроенных электронных имплантов.\\
Аппаратный - предназначений для взаимодействия физических устройств друг с другом: тип разъёмов и параметры сигналов передаваемых через эти разъёмы.\\
\section*{Задание. Процесс.}
Задание - совокупности программы и входных данных, необходимых для её выполнения. \\
Процесс - экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы, например, процессорное время и память. Каждый процесс выполняется в отдельном адресном пространстве. Один процесс не может получить доступ к данным другого процесса.\\
Понятие процесса включает:\\
1. Множество внешней по отношению к процессу информации, используемой ОС для управления ресурсом типа «процесс». Состав данной информации зависит от ОС.\\
2. Структура и содержимое адресного пространства процесса. Т.е. части памяти, выделенной процессу.\\
3. Множество ресурсов, принадлежащих процессу или используемых процессом, а также состояние этих ресурсов.\\
\section{Архитектура ОС}
\setcounter{section}{1}
\subsection{Монолитная ОС}%
\setcounter{subsection}{1}
В монолитной ОС система организуется как набор процедур, каждую из которых может вызывать пользовательская программа. Вся ОС расположена в едином адресном пространстве. \\
Пользовательский режим - процесс не может получить доступ к чужой области памяти, не все инструкции процессора ему доступны. Поток, исполняющийся в пользовательском режиме, может получить доступ к системным ресурсам только посредством вызова системных сервисов. Когда программа пользовательского режима вызывает системный сервис, вызов перехватывается и вызывающий процесс переключается в режим ядра.\\
Режим ядра - привилегированный режим работы процессора, в котором исполняется код ОС. Поток, исполняющийся в режиме ядра, имеет доступ ко всей памяти и аппаратуре.\\
Системные сервисы - набор программ, которые перехватывают обращение прикладных программ к системным ресурсам. Когда выполнение системного сервиса завершается, ОС переключает поток обратно в пользовательский режим.\\
Привилегия - это свойство, устанавливаемое при проектировании системы, которое определяет, какие компьютерные операции разрешены, какие доступы к памяти законны. Привилегии испльзуются для обеспечения безопасности в компьютерной системе и повышения надёжности её работы.\\
Привилегии реализуются путём присвоения процессам значения от 0 до 3. Значение 0 соответствует наибольшим привилегиям, тогда как значение 3 - наименьшим.\\
Привилегии реализуются на уровне процессора.\\
\begin{center}
Достоинства монолитной ОС
\end{center}
1. Высокая скорость\\
2. Относительно простая разработка ОС:\\
\begin{center}
Недостатки:
\end{center}
1. Поскольку всё ядро работает в одном адресном пространстве, сбой в одном из компонентов может нарушить работоспособность всей системы.\\
2. Усовершенствование ОС затруднено, т.к. внесение изменений в одну часть ОС может потребовать внесение изменений в другие части ОС.\\
Примеры монолитных ОС: MS DOS, первые версии MacOS\\
\subsection{Модульная операционная система}
\setcounter{2}\\
Модульная ОС - это ОС, в которой каждый программный модуль (часть ОС) имеет законченное функциональное назначение с оговорёнными правилами взаимодействия. Все модули ОС равнозначны. В отличие от монолитной ОС, каждому модулю выделена своя область памяти. Все модули исполняются в режиме ядра.\\
\begin{center}
	Достоинства модульной ОС:
\end{center}
1. Упрощается усовершенствование ОС\\
2. Достаточно высокая надёжность ОС, т.к. сбой в одном модуле не влияет на другие\\
\begin{center}
	Недостатки модульной ОС:
\end{center}
1. Усложняется создание ОС\\
Модульную архитектуру имеет разновидность UNIX - FreeBSD.
Linux имеет монолитно-модульную архитектуру.
\subsection{Послойная ОС}
Достоинства:\\
1. упрощается усовершенствование ОС\\
2. Достаточно высокая надёжность ОС\\
Недостатки:\\
1. Уменьшение быстродействия ОС.\\
Частично послойную архитектуру имеет ОС Windows.
\subsection{Микроядерные ОС}
В сложном программном продукте в среднем содержится 10 ошибок на 1000 строк кода. Следовательно, монолитная операционная ОС, состоящая из 5000000 строк кода, скорее всего, содержит от 10000 до 50000 ошибок. Таким образом, для уменьшения количества ошибок надо уменьшать размер кода, работающего в привилегированном режиме.\\
MacOS X использует микроядерную архитектуру, которая основана на микроядре Mach. При этом используются некоторые модули, взятые из ОС FreeBSD.\\
Harmony OS - микроядерная ОС, устанавливается на смартфоны компании Huawei.\\
Микроядро MINIX 3 занимает всего лишь около 12000 строк кода на языке C и 1400 строк кода на ассемблере.\\
\begin{center}
	Достоинства микроядерной ОС:
\end{center}
1. Достаточно высокое быстродействие\\
2. Высокая надёжность. Микроядерную архитектуру используют ОС, работающие в реальном масштабе времени в промышленных устройствах, авиации и военной технике.\\
\begin{center}
	Недостатки микроядерной ОС:
\end{center}
1. Сложность разработки\\
2. При увеличении числа процессов значительно падает быстродействие, т.к. увеличивается число обращений к ядру.
\subsection{Клиент-серверная ОС}
Клиент-серверная ОС разделяет процессы на два типа:\\
1. Процесс сервера, каждый из которых предоставляет какую-нибудь службу\\
2. Процесс клиента, который пользуется этими службами.\\
Для свзяи клиентов с серверами используется ядро (микроядро).\\
Связь между клиентами и серверами организуется с помощью передачи сообщений следующим образом:\\
1. Клиентский процесс составляет сообщение, в котором говорится, что именно ему нужно, и отправляет его ядру или микроядру.\\
2. Ядро или микроядро ОС определяет, какой сервер должен ответить на сообщение, и доставляет сообщение серверу.\\
3. Служба выполняет определённую работу и отправляет обратно ответ.\\
4. Ядро возвращает клиенту результат в виде другого сообщения.\\
\section*{Требования к ОС}
\setcounter{section}{2}
Требования правительства США.
\subsection{Совместимость с POSIX}%
\setcounter{subsection}{6}
Lorem Ipsum
\subsection{Безопасность}%
\setcounter{subsection}{7}
Безопасность, то есть защита от несанкционированного доступа. Требования, выполнение которых делает систему многопользовательской.\\
А. Защита от несакционированного проникновения на компьютер.\\
Б. Защита ресурсов пользователя от других пользователей.\\
В. Возможность установления квот на системные ресурсы для предотвращения захвата одним пользователем всех системных ресурсов.\\
Г. Разграничение прав доступа пользователей к файлам и устройствам.\\
Д. Сохранение информации о действиях пользователей, связанных с безопасностью.\\
\section{Особенности реализации ОС Windows}
\setcounter{section}{3}
\setcounter{subsection}{0}
\begin{center}	
	\includegraphics[scale=0.3]{1}
\end{center}
Ядро (kernel) - компонент операционной системы, непосредственно взаимодействующий с процессом и памятью. Выполняет планирование и переключение потоком, обработку прерываний и исключений, взаимодействие с драйверами и мультипроцессорную синхронизацию.\\
В Windows также реализована идея помещать в ядро исполнительный механизм, а не политику.\\
\subsection{Поток}%
В Windows - процесс не является испольняемой сущностью, т.е. непосредственно не выполняется процессором. Это некий объект, который характеризует задачу во время испольнения.\\
Исполняемая сущность внутри процесса - это поток выполнения (thread of execution).\\
Поток - это программа, выполняющаяся в адресном пространстве процесса и имеющая доступ ко всем ресурсам процесса. Каждый процесс должен содержать не менее одного потока. Как правило, в Windows процесс содержит несколько потоков.\\
Поток - это способ распараллеливания вычислительных операций и экономии памяти.\\
В то время как процесс - это логическое предстваление работы, которую должна выполнить программа, поток отображает одну из многих необходимых подзадач.\\
\subsection{Прерывания}
Прерывания (interrupt) - это запрос, поступающий от устройства ввода-вывода, исполняющейся программы или процессора с требованием прервать выполнение текущей программы и запустить на выполнение другую программу. Прерывания бывают внешние и внутренние.\\
Внешние прерывания являются внешними по отношению к процессору, поэтому так и называются. Внешние прерывания бывают друх типов: прерывания ввода-вывода и аппаратные прерывания.\\
Прерывания ввода-вывода создают переферийные устройства, которые сообщают, что они готовы выполнить операцию ввода или вывода. Для выполнения операции ввода-вывода надо прервать выполнение текущей программы и выполнить программу управления вводом-выводом. Программа, вызываемая при возникновении прерывания называется программонй обработки прерывания.\\
Аппаратные прерывания поступают в процессор от различных устройств компьютера и не связаны с вводом-выводом. Они сигнализируют о наступлении какого-нибудь события или об обнаружении сбоев в работе какого-нибудь устройства. В этом случае тоже вызывается соответсвтующая программа обработки прерывания.\\
Внутренние прерывания происходят внутри процессора и бывают двух типов:\\
Программными прерываниями считаются запросы со стороны программы на начало выполнения операции ввода-вывода или при обращении к функциям операционной системы.\\
Исключительные ситуации (исключения) возникают в тех случаях, когда процессор не в состоянии выполнить предусмотренное в программе действие, например, деление на ноль. В этом случае он прерывает выполнение программы и сообщает операционной системе о наличии исключительной ситуации, а также выдаёт необходимую дополнительную информацию, которая позволяет более точно определить причину её возникновения.\\
\begin{center}	
	Исключительные ситуации бывают следующих типов:\\
\end{center}
Деление на ноль\\
Пошаговая работа (трассировка)\\
Переполнение порядка при работе со знаковым операндом\\
Выход индекса за границу, т.е. обращение к области памяти не принадлежащей к данной программе. В этом случае выдаётся ошибка General Protection Fault. (Нарушения основной защиты)\\
Другие исключительные ситуации\\
\subsection{Уровень абстрагирования от оборудования}
Ядро осуществляет взаимодействие с устройствами, но не непосредственно, а через уровень абстрагирования от оборудования. Чтобы работа ядра не зависела от аппаратного обеспечения введён слой абстрагирования от оборудования HAL (Hardware Abstraction Layer).\\
В HAL входит загружаемый модуль режима ядра (\url{C:\Windows\System32\hal.dll}, предоставляющий низкоуровневый интерфейс с аппаратной платформой, на которой выполняется Windows. Он скрывает от ОС специфику конкретной аппаратной платформы, т.е. все функции, зависимые от архитектуры и от конкретной машины. Таким образом, ядро работает с некоей стандартизированной виртуальной машиной. HAL преобразует команды ядра в команды, понятные конкретному оборудованию.\\
Также в HAL входят драйверы различных переферийных устройств.\\
DLL (Dynamic Link Library) - динамически подключаемая библиотека, подпрограмма, позволяющая многократное использование различными программными приложениями. К DLL относятся разные программные компоненты и в частности драйверы.\\
В системах UNIX также используются библиотеки. Они имеют расширение .so (shared object).\\
\subsection{Исполнительная система}
Исполнительная система (executive system) - спроектирована как уровень абстрагирования от ядра. Она обеспечивает специфические политики для управления объектами, памятью, процессами, файлами и устройствами. Таким образом, ядро реализует механизм, а исполнительная система - политику.\\
Ядро и исполнительная система включаются в один исполняемый модуль NTOSKRNL.EXE.
\begin{center}
	\includegraphics[scale=0.3]{2}
\end{center}
\begin{center}
Основные модули исполнительной системы:
\end{center}
1. Диспетчер объектов (Object Manager).\\
2. Диспетчер процессов и потоков (Process and Thread Manager).\\
3. Диспетчер виртуальной памяти (Virtual Memory Manager).\\
4. Справочный монитор защиты (Security Reference Monitor).\\
5. Диспетчер ввода-вывода (I/O Manager).\\
6. Диспетчер кэша (Cache Manager).\\
7. Средство локального вызова процедур (Local Procedure Call).\\
\subsection{Подсистема}
Подсистема - это программный модуль, который выступает в качестве сервера. При помощи подсистем реализуется клиент-серверная архитектура.
\begin{center}
	\includegraphics[scale=0.3]{3}
\end{center}
\begin{center}
	\includegraphics[scale=0.3]{4}
\end{center}
\subsection{Приоритеты Windows}
В Windows используется приоритетный, с вытеснением и кватованием времени планировщик.\\
Процессор выделяется потоку на квант времени, вычисляемый, как несколько тиков системных часов. Планировщик поддерживает 32 уровня приоритета и соответственно столько же различных очередей планировщика.\\
Алгоритм работы планировщика такой:\\
\begin{itemize}	
\item В соответствии с приоритетом выполнения потоков создаётся несколько очередей. В каждой очереди потоки только с одинаковым приоритетом.\\
\item Сначала выполняются потоки из очереди с самым высоким приоритетом.\\
\item Если в этой очереди нет больше потоков, тогда планировщик будет обслуживать очередь второго по величине приоритета, потом третьего и т.д.\\
\end{itemize}
\begin{center}
	\includegraphics[scale=0.3]{5}
\end{center}
Самый высокий приоритет у потоков реального времени, он больше чем у потоков ОС. Такой приоритет нужен для обработки высокоскоростных потоков данных, которые нужно обрабатывать в реальном времени.\\
На динамическом уровне выполняются почти все прикладные системные процессы. Особенностью данного уровня является то, что приоритеты потоков могут меняться в течение времени в зависимости от ситуации и действий пользователя. Приоритет повышается для тех потоков, с которыми непосредственно в данный момент работает пользователь.\\
Системный уровень предназначен для одного системного процесса Idle. Этот процесс обладает самым низким приоритетом и работает, когда процессор простаивает. Процесс Idle удаляет ненужные данные из файла подкачки, также снижает энергопотребление процессора при простое. На каждом ядре процессора запускается по одному потоку процесса Idle.\\
\begin{center}
	\includegraphics[scale=0.3]{6}
\end{center}
Приоритеты процессов могут принимать не все возможные значения от 0 до 31, а только несколько определённых значений.\\
\begin{itemize}
	\item Real Time Class (значение 14)
	\item High Class (значение 13)
	\item Above Normal class (значение 10)
	\item Normal Class (значение 8)
	\item Below Normal Class (значение 6)
	\item Idle Class (значение 4)
\end{itemize}
По умолчанию приоритет процесса наследуется от родительского процесса следующим образом:\\
\begin{itemize}
	\item Если приоритет родительского процесса Normal или ниже, то дочерний процесс имеет приоритет равный родительскому
	\item Если приоритет родительского процесса выше Normal, то дочерний процесс имеет приоритет Normal.
\end{itemize}
Приоритет потока - величина, складывающаяся из двух составных частей: приоритета породившего поток процесса и собственно приоритета потока.\\
Приоритет потока задаётся относительно приоритета процесса.
\begin{itemize}
	\item Normal: такой же какой и у процессора
	\item Above normal: +1 к приоритету процесса
	\item Below normal: -1;
	\item Highest: +2;
	\item Lowest: -2;
	\item Time critical: устанавливает базовый приоритет потока для Real Time в 31, для остальных классов в 15;
	\item Idle: устанавливает базовый приоритет потока для Real Time класса в 16, для остальных классов в 1.
\end{itemize}
\begin{center}
	Зависимость приоритета потока от приоритета процесса.\\
	\includegraphics[scale=0.3]{7}
\end{center}
Многопоточность приложений нужна для следующих целей:\\
Распараллеливания вычислений для ускорения работы программы за счёт того, что разные потоки выполняются на разных ядрах.\\
Задания разным потокам разных приортетов для повышения удобства работы пользователя с программой. Таким образом базовый (начальный приоритет потока определяется процессом, но ОС может его менять для удобства работы пользвователя с программой. Когда пользователь непосредственно взаимодействует с потоком ОС повышает приоритет потока. Если пользователь перестаёт взаимодействовать с этим потоком, то приоритет понижается.\\
\subsection{Изменение приоритетов}
Используя системные функции Windows, программист может задать приоритет процесса при его создании и в дальнейшем при необходимости изменить.\\
Для создания процесса используется системная функция CreateProcess. Эта функция позволяет задать класс приоритета создаваемого процесса.\\
Приоритет процесса можно изменить и после его создания, используя функцию SetPriorityClass.\\
Команда Start позволяет создать процесс и задать его приоритет.\\
Пользователь получает доступ к функции SetPriorityClass, используя специальные утилиты, например, диспетчер задач и Process Explorer.\\
Изменение приоритетов индивидуальных потоков внутри процесса обычно не имеет смысла, так как программист определил приоритеты потоков в соответствии с логикой работы программы. Изменение относительных приоритетов потоков может привести к неадекватному поведения приложения.\\
\section{Кеш-память}
\setcounter{subsection}{0}
Кэш-память - это промежуточная память которая сглаживает разницу в быстродействии основных видом памяти. Использование кэш-памяти значительно ускоряет обмен данными между устройствами.\\
\begin{center}
	\includegraphics[scale=0.3]{8}
\end{center}
Экспериментально установлено, что после обработки некоторых данных процессор с большой вероятностью обращается к тем же самым данным или к данным, находящимся в непосредственной близости от них. Это явление называется принципом пространственной локализации.\\
Также установлено, что программе в ближайшее время, вероятнее всего, потребуются данные, которые использовались недавно. Эта закономерность называется принципом временной локализации.\\
Эти два принципа используются для ускорения обмена данными с дисковыми накопителями.\\
При чтении данных с диска читаются не только требуемые данные, но и данные находящиеся рядом, т.е. читается не один блок данных, а несколько. Прочитанные данные автоматически заносятся в кэш. Эта процедура называется упреждающее чтение.\\
Перед чтением данных с жёсткого диска выполняется попытка чтения данных из кэша. Если нужные данные действительно находятся в кеше, то они с высокой скоростью записываются в основную часть оперативной памяти, не относящейся к кешу. Эта ситуация носит название попадание в кеш. Если данные в кеше отсутствуют, то говорят, что имеет место промах кеша, и данные читаются с диска.\\
Если кеш заполнен полность, то при записи новых данных удаляются те данные, которые записаны давно и продолжительное время не использовались\\
Такое накопление данных называется кешированием.\\
При записи данных на диск сначала происходит запись в кеш. Существует 3 способа записи на диск:\\
\begin{enumerate}
        
	\item Прямая запись - данные из кеша сразу записываются на жёсткий диск. Это самый надёжный, но самый медленный вариант.\\
\item Обратная запись - данные из кеша записываются на жёсткий диск в первом же свободном такте работы процессора. Эта схема использует некоторую задержку во времени относительно момента записи в кеш. Благодаря этому она более эффективна, чем схема прямой записи.\\
\item Отложенная запись - запись на жёсткий диск выполняется только при окончательном заполнении кеша, то есть когда для помещения в кеш нового значения не оказывается свободной области.\\
\end{enumerate}
Использование кеш-памяти уменьшает количество обращений к жёсткому диску. Благодаря этому происходит ускорение обмена данными с дисковыми накопителями.\\
Обратная и отложенная запись значительно ускоряют работу с дисковыми накопителями, но существует риск потери данных при отключении питания компьютера или при потери связи с накопителем.\\
В Windows кэшем в оперативной памяти управляет соответствующий модуль в исполнительной системе - диспетчер кеша. Диспетчер кеша в частности определяет какая часть оперативной памяти выделяется под кеш.\\
\section{Виртуальная память}
\setcounter{subsection}{0}
Виртуальная память - метод управления памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем, например, жёстким диском.\\
Достоинства использования виртуальной памяти:\\
\begin{itemize}
        \item Программа не ограничена объёмом физической оперативной памяти. Успрощается разработка программ, поскольку можно задействовать большие виртуальные пространства, не заботясь о размере используемой памяти.\\
        \item Поскольку появляется возможность частичного помещения программы (процесса) в память и гибкого перераспределения памяти между программами, можно разместить в памяти больше программ, что увеличивает загрузку процессора и пропускную способность системы.	
\end{itemize}
\subsection{Файл подкачки.}
Файл подкачки - это область на жёстком диске, которая повторяет структуру оперативной памяти и имеет такую же адресацию как оперативная память.\\
Файл подкачки можно назвать виртуальной памятью. Размер виртуальной памяти гораздо больше оперативной и ограничен только размером жёсткого диска и величиной адресного пространства процессора.\\
При запуске программы на выполнение создаётся процесс и этому процессу выделяется виртуальное адресное пространство. Таким образом, код и данные копируются сначала в виртуальную память, а потом по мере необходимости по частям копируются из виртуальной памяти в оперативную.\\
В Windows виртуальная память находится в фалй \url{pagefile.sys} или \url{swap.sys}. Этот файл называется файлом подкачки или своп-файлом. Размер этого файла обычно в 2 раза больше размера оперативной памяти.\\
В ОС Unix и Linux вместо файла подкачки используется раздел подкачки - область на жёстком диске, выделенная для виртуальной памяти.\\
В MacOS используется несколько файлов подкачки.\\
\url{/private/var/vm/swapfile0,.../swapfile1,.../swapfile2,...}\\
В операционных системах iOS и Android файла подкачки нет.\\
\subsection{Страничная организация памяти}
Для организации виртуальной памяти адресное пространство, подразделяется на блоки памяти 4 КБ или 4 МБ каждый. Такие блоки называются логическими страницами.\\
Фактически имеющаяся в компьютере оперативная память также делится на участки длиной 4 КБ или 4 МБ, которые называются страничными кадрами.\\
При объёме оперативной памяти 4ГБ образуется 1024 страничных кадра.\\
\begin{center}
        \includegraphics[scale=0.3]{9}
\end{center}
\begin{center}
        \includegraphics[scale=0.3]{10}
\end{center}
При любом обращении к памяти определяется, находится ли связанная с сегментом логическая страница в оперативной памяти. Если страница находится в памяти, то происходит прямое обращение к ней.\\
В противном случае нужная логическая страница автоматически загружается (подкачивается) операционной системой с жёсткого диска в один из неиспользуемых или редко используемых страничных кадров оперативной памяти.\\
Адрес в оперативной памяти отличаается от адреса в виртуальной памяти. Для доступа к нужной ячейке памяти нужно осуществить преобразование логического адреса в виртуальной памяти в физический адрес в оперативной памяти. Это преобразование осуществляется диспетчером виртуальной памяти.\\
\subsection{Адресация памяти}
Следует понимать разницу между возможностью адресации виртуальной памяти и возможностью адресации физической памяти. Адресация виртуальной памяти определяется типом процессора.\\
Максимальный размер адресуемой физической памяти зависит ещё и от операционной системы. Так 32-разрядная ОС Windows может адресовать не более 4ГБ физической памяти. Windows 10 x64 Home может адресовать 128 ГБ, остальные 64-х разрядные версии 2ТБ.
\subsection{Диспетчер виртуальной памяти.}
В Windows виртуальной памятью управляет диспетчер виртуальной памяти. Диспетчер виртуальной памяти выполняет следующие действия:
\begin{enumerate}
	\item Выделяет и освобождает виртуальное адресное пространство
        \item Обеспечивает своевременную подкачку данных из виртуальной памяти в физическую
	\item Обеспечивает отображение логических адресов виртуальной памяти в физические адреса оперативной памяти.
\end{enumerate}
\section{Диспетчер объектов}
\setcounter{subsection}{0}
Объектом является любая именованная составляющая компьютерной системы с которой работает ОС Windows за исключением процессора и памяти.\\
Диспетчер объектов управляет объектами и организует доступ процессов к объектам.
\begin{enumerate}
        \item Создаёт и удаляет объект
	\item Предоставляет доступ к объекту
	\item Изменяет информацию об объекте
\end{enumerate}
Объекты бывают двух видов:
\begin{enumerate}
        \item Объекты, отражающие реальные сущности, существующие в компьютерной системе: файлы, папки, принтеры и т.д.
	\item Объекты, не отражающие реальные сущности и необходимые для корректной работы процессов: семафоры, мьютексы и т.д.
\end{enumerate}
Если процессу нужен доступ к какому-нибудь объекту, то происходит обращение к диспетчеру объектов. Диспетчер объектов выполняет следующие действия:
\begin{enumerate}
        \item Определяет существует ли требуемый объект
	\item Если объект не существует, то он создаётся
	\item Для доступа процесса к объекту создаётся описатель объекта (handle). В Windows он называется дескриптор.
	\item Описатель возвращается процессу. 
\end{enumerate}
В дальнейшем при обращении к объекту прикладной процесс передаёт описатель соответствующей функции API, через которую происходит обращение к объекту.\\
Когда другой процесс попытается обратиться к уже существующему объекту, то диспетчер объектов создаёт второй описатель объёкта для этого процесса. Таким образом, число описателей в операционной системе гораздо больше числа объектов.\\
В Windows существует 15 типов объектов. При создании объектов, диспетчер объектов создаёт запись, содержащую информацию об объекте. Эта запись содержит заголовок и тело. Заголовок используется диспетчером объектв для управления объектом. Тело содержит зависимою от типа объекта, информацию, позволяющую получить доступ к объекту. Заголовок включает в себя следующие данные:
\begin{itemize}
	\item Имя объекта. Позволяет различным процессам ссылаться на объект.
	\item Дескриптор защиты. Содержит разрешения доступа.
	\item Информация об открытых описателях. Содержит информацию о том, какие процессы используют описатели объекта.
	\item Тип объекта. Один из 15 типов.
	\item Счётчик ссылок. Содержит количество открытых описателей объекта.
\end{itemize}
\section{Диспетчер потоков и процессов.}
\setcounter{subsection}{0}
Диспетчер процессов и потоков выполняет следующие действия:
\begin{itemize}
	\item Создание и уничтожение процессов и потоков.
	\item Выделяет память созданному процессу.
	\item Управляет изменениями состояния процессов и потоков.
	\item Сохраняет необходимую информацию о каждом процессе и потоке.
	\item Удаляет зависшие процессы.
	\item Ведёт подсчёт потребляемыми ресурсами.
\end{itemize}
Для управления процессами и потоками диспетчер процессов сохраняет информацию о каждом процессе и потоке в памяти.\\
Для сохранения информации о процессе создаётся дескриптор процесса. Он называется \textbf{executive process control block (EPROCESS)}. При создании потока создаётся дескриптор потока \textbf{executive thread process control block (ETHREAD)}.
\section{Справочный монитор защиты}
\setcounter{subsection}{0}
Справочный монитор защиты выполняет второй этап авторизации - проверяет права доступа процесса к объекту.\\
Когда поток пытается получить досутп к объекту, его запрос передаётся справочному монитору защиты. Каждый объект имеет дескриптор безопасности, который содержит \textbf{владельца объекта и список контроля доступа (access conrol list, ACL)}.\\
\textbf{Список контроля доступа} содержит список пользователей, которым разрешён доступ к объекту. Также в этом списке содержится информация с какими правами разрешён доступ пользователя к объекту. В компьютере от имени пользователя действует процесс.\\
Справочный монитор защиты определяет индентификатор процесса и тип требуемого им доступа, а затем проверяет, разрешён ли ему заданный доступ.
\section{Средство локального вызова процедур}
\setcounter{subsection}{0}
Средство локального вызова процедур - механизм исполнительной системы для обмена сообщениями между клиентом и сервером. LPC реализует клиент-серверную архитектуру следующим образом.
\begin{enumerate}
        \item После запуска процесса сервера, он создаёт объект типа именованный порт (named pipe). Через этот порт можно соединиться с сервером.
	\item Клиент запрашивает соединение с объектом типа порт, отправив соответствующее сообщение.
	\item Если сервер отвечает на запрос, создаются два безымянных порта.
	\begin{enumerate}
	\item Коммуникационный порт клиента используется процессом клиентом для связи с сервером;
	\item Коммуникационный порт сервера для связи с клиентом, по одному порту на каждого клиента;
	\end{enumerate}
	\item Клиент получает описатель (handle) серверного порта от LPC, а сервер получает описатель клиентского порта. Таким образом, устанавливается связь между процессами.
\end{enumerate}
LPC поддерживает 3 способа передачи сообщений между клиентом и сервером:
\begin{enumerate}
        \item Сообщение короткое - меньше или равно 256 байт. Ядро копирует сообщение из адресного пространства одного процесса в системное адресное пространство, а оттуда в адресное пространство дрегого процесса.
	\item Сообщение длиной более 256 байт:
	\begin{enumerate}
	        \item LPC создаёт область памяти, разделяюемую между двумя разными процессами.
		\item Первый процесс записывает данные в разделяемую область памяти.
		\item Первый процесс отправляет методом 1 сообщение, что можно считать данные из разделяемой области памяти.
		\item Второй процесс считывает данные.
	\end{enumerate}
	\item Если объём передаваемых данных очень большой, и эти данные надо передавать с минимальной задержкой, то сервер читает и записывает данные прямо в адресное пространство клиента.
\end{enumerate}
\section{Блок управления процессом и потоком, контекст процесса}
\setcounter{subsection}{0}
Информация о процессе хранится в специальной структуре данных, которая называется \textbf{Process Control Block (PCB) - блок управления процессом}. Есть аналогичный \textbf{блок управления потоком Thread Control Block (TCB)}\\
В этих блоках содержится следующая информация:
\begin{enumerate}
        \item Идентификатор процесса или потока - уникальный номер, используется для идентификации процесса или потока.
	\item Групповые параметры процесса: родительский процесс, дочерние процессы, процессы, принадлежащие одному заданию и т.д.
	\item Приоритет процесса или потока.
	\item Состояние процесса или потока.
	\item Статистические данные: время создания процесса; время процессора, использованное всеми потоками процесса; время процессора, использованное каждым потоком и т.д.
	\item Описание виртуального адресного пространства процесса.
	\item Контекст ввода-вывода - информация, определяющая возможности процесса по взаимодействию с устройствами ввода-вывода. Для процесса может быть указан объект с которого он может получать входные данные, и объект, куда процесс должен осуществлять вывод.
	\item Контекст безопасности: владелец процесса, группы к которым принадлежит владелец процесса.
	\item Текущие системные параметры выполнения: логический диск, рабочий каталог, системные переменные и т.д.
	\item Код завершения процесса или потока.
\end{enumerate}
Блок управления процессом содержит всю необходимую операционной системе информацию для управления процессом, поэтому данный блок называют системным контекстом процесса.\\
Содержимое всех регистров процессора называется регистровый контекст процесса.\\
Код и данные, находящиеся в адресном пространстве процесса, - это пользовательский контекст процесса.\\
Код и данные, находящиеся в адресном пространстве процесса - это пользовательский контекст процесса.\\
Совокупность регистрового, системного и пользовательского контекстов процесса принято называть контекстом процесса.\\
\section{Состояние потока (процесса)}
\setcounter{subsection}{0}
\begin{center}
	\includegraphics[scale=0.3]{11}
\end{center}
\begin{center}
	\includegraphics[scale=0.3]{12}
\end{center}
\subsection{Рождение процесса}
\begin{enumerate}
        \item Создаётся Process Control Block процесса.
	\item Задаётся ID процесса.
	\item Процессу выделяется адресное пространство в виртуальной памяти и другие ресурсы.
	\item Программа и данные загружаются в виртуальное адресное пространство процесса.
	\item Устанавливается начальное значение программного счётчика процесса.
\end{enumerate}
Родившийся процесс переводится в состояние "готовность".\\
Инициатором рождения нового процесса является другой процесс: системный или пользовательский. Для создания процесса нужно выполнить специальный системный вызов.\\
Процесс, инициировавший создание нового процесса, называется родительским процессом. Созданный процесс называется дочерним процессом. Дочерние процессы могут создавать другие процессы, в результате возникает дерево процессов. Если таких деревьев возникает несколько, то они называются лесом.
\begin{center}
	\includegraphics[scale=0.3]{13}
\end{center}
Для выполнения своих функций новому процессу требуются определённые ресурсы: память, файлы, устройства ввода-вывода и т.д. Существует два подхода к их выделению:
\begin{enumerate}
        \item Новый процесс получает в своё пользование ресурсы родительского процесса. В Windows таков подход используется при создании потоков.
	\item Новый процесс получает свои ресурсы непосредственно от операционной системы. В Windows такой подход используется при создании процессов.
\end{enumerate}
Информация о выделенных ресурсах заносится в PCB (Process Control Block).\\
После выделения процессу адресного пространства нужно занести туда код и данные. При этом может использоваться один из двух методов:
\begin{enumerate}
	\item Дочерний процесс становится дубликатом родительского процесса по регистровому и пользовательскому контекствам. В дальнейшем требуемые код и данные загружаются из файла, меняется также регистровый контекст. Такой подход используется в UNIX и Linux.
	\item Дочерний процесс сразу загружает пользовательский контекст из файла. Такой подход используется в Windows.
\end{enumerate}
После того как процесс наделён содержанием, в PCB дописывается оставшаяся информация и состояние нового процесса меняется на \textbf{готовность}.\\
Рассмотрим как ведут себя родительские процеесы после создания дочерних процессов:
\begin{enumerate}
        \item Родительский процесс продолжает своё выполнение одновременно с дочерним процессом.
	\item Родительский процесс ожидает завершение дочернего процесса.
\end{enumerate}
\subsection{Завершение процесса.}
Рассмотрим, что происходит после того, как процесс завершил свою работу.
\begin{enumerate}
        \item Операционная система переводит его в состояние \textbf{"закончил исполнение"}
	\item Освобождает все ассоциированные с ним ресурсы, делая соответсвующие записи в блоке управления процессом.
\end{enumerate}
При этом PCB завершённого процесса не уничтожается, а остаётся в системе ещё некоторое время. Это связано с тем, что родительский процесс после завершения дочернего процесса может запросить операционную систему информацию о работе дочернего процесса. В первую очередь может понадобиться код завершения процесса. Также может понадобиться статистичечкая информация по работе дочернего процесса.\\
Подобная информация сохраняется в PCB завершённого процесса до запроса родительского процесса или до конца его работы, после чего PCB удаляется. В операционной системе UNIX процессы, находящиеся в состоянии \textbf{закончил исполнение} , принято называть \textbf{процессами зомби}.\\
В некоторых операционных системах, например, в системах реального времени, завершение родительского процесса приводит к завершению работы всех дочерних. В Windows, UNIX, MacOS дочерние процессы продолжают своё существование и после окончания работы родительского процесса.\\
В Windows после завершения родительского процесса дочерний утрачивает связь с деревом процессов и становится началом нового дерева.
В UNIX для такого процесса родительским процессом становится системный процесс \textbf{init}. В результате дерево процессов сохраняет свою целостность. 
\subsection{Запуск потока (процесса).}
Из числа потоков, находящийся в состоянии готовность, операционная иситема выбирает один поток для последующего исполнения
\begin{enumerate}
        \item Для выбранного потока операционная система обеспечивает наличие в оперативной памяти информации, необходимой для его дальнейшего исполнения.
	\item Состояние потока меняется на исполнение.
	\item Восстанавливаются значения регистров для данного потока, и управление передаётся команде, на которую указывает счётчик команд потока.
\end{enumerate}
Все данные, необходимые для восстановления контекства, извлекаются из PCB потока.
\subsection{Приостановка потока (процесса).}
Работа потока, находящегося в состоянии исполения, приостанавливается в результате какого-либо прерывания.
\begin{enumerate}
        \item Процессор сохраняет счётчик команд и содержимое регистров в стеке потока.
	\item Процессор передаёт управление программе обработки прерывания. Начало программы обработки прерывания должно находится по определённому адресу.
	\item Программа обработки прерывания сохраняет системный и регистровый контекст в его PCB.
	\item Программа обработки прерывания переводит потокк в состояние готовность.
	\item Программа обработки прерывания приступает к обработке прерывания, то есть к выполнению определённых действий, связанных к возникшим прерываниям.
\end{enumerate}
\subsection{Блокировка и разблокировка потока (процесса).}
Поток блокируется, когда он уже не может продолжать свою работу, не дождавшись возникновения какого-либо события в вычислительной системе.\\
Блокирование происходит, когда поток обращается к операционной системе с помощью системного вызова. Операционная система обрабатывает системный вызов следующим образом:
\begin{enumerate}
        \item Сохраняет контекст потока.
	\item Переводит поток из состояния исполнение в состояние ожидание.
	\item Добавляет поток в очередь потоков, дожидающийся возникновения события.
	\item Инициализирует операцию ввода-вывода или другое действие.
\end{enumerate}
После возникновения в системе какого-либо события, операционная система определяет, какой поток ожидает это событие. Данный поток переводится в состояние готовность.
\subsection{Переключение контекста}
Для корректного переключения процессора с одного потока на другой необходимо \textbf{сохранить контекст} исполняющегося потока и \textbf{восстановить контекст} потока, на который будет переключен процессор. Такая процедура сохранения\восстановления работоспособности потоков называется \textbf{переключением контекста}. Время, затраченное на переключение контекста, не используется вычислительной системой для совершения полезной работы и представляет собой накладные расходы, снижающие производительность системы. Оно определяется быстродействием компьютера и находится в диапазоне от 1 до 1000 микросекунд.  
\section{Вытесняющее и невытесняющее планирование.}
\setcounter{subsection}{0}
Процесс планирования осуществляется частью операционной системы, называемой \textbf{планировщиком}. В большинстве операционных систем в том числе Windows \textbf{планировщик} является частью ядра. \textbf{Планировщик} может принимать решения о выборе для исполнения нового потока, из числа находящийся в состоянии \textbf{готовность}, в следующих четырёх случаях:
\begin{itemize}
        \item Когда поток переводится из состояния \textbf{исполнение} в состояние \textbf{завершение}
	\item Когда поток переводится из состояния \textbf{исполнение} в состояние \textbf{ожидание}
        \item Когда поток переводится из состояния \textbf{исполнение} в состояние \textbf{готовность} (например, после прерывания от таймера)	
        \item Когда поток переводится из состояния \textbf{ожидание} в состояние \textbf{готовность} (завершилась операция ввода-вывода или произошло другое событие)
\end{itemize}
Следует отметить, что в двух случаях прерывания поток самостоятельно останавливает свою работу. В друх других - работа потока останавливает извне.\\
Когда используется все четыре варианта остановки потока для осуществления планировани, такой механизм называется \textbf{вытесняющее планирование}. \textbf{Вытесняющее планирование} используется во всех современных ОС разделения времени.\\
Если в операционной системе не используется механизм прерывания извне, то планирование осуществляется только в том случае, когда поток сам прерывает свою работу. Такой механизм называется \textbf{не вытесняющее планирование}. 
Не вытесняющее планирование использовалось в MS DOS, MacOS ранних версий, а также в 16-разрядных версиях Windows.\\
Не вытесняющее планирование относительно просто реализуется и достаточно эффективено, так как позволяет использовать большую часть процессорного времени на работу самих процессов и до минимума снизить затраты на переключение контекстов. Однако при не вытесняющем планировании возникает проблема возможности полного захвата процессора одним зависшим процессом. В таком ситуации необходимо использовать перезагрузку всей вычислительной системы. При вытесняющем планировании такой проблемы нет.\\
Рассмотрим реализацию механизма прерывания в случае окончания кванта времени, выделенного на выполнение потока.
\begin{enumerate}
        \item Системный таймер отсчитывает квант времени.
	\item По истечении времени, отведённого на выполнение потока сигнал подаётся на специальный вход процессора. Создаётся аппаратное прерывание.
	\item Процессор получает сигнал прерывания и останавливает выполнение команд потока. В стеке сохраняется содержимое регистров процессора.
	\item Сигнал прерывания содержит номер прерывания. По этому номеру процессор вызывает нужную программу обработки прерывания. В данном случае вызывается планиройщик
	\item  Планировщик записывает регистровый контекст из стека в специальную область памяти
	\item При помощи диспетчера процессов делаются необходимые изменения в блоке управления потоком.
	\item Выбирается поток для запуска.
	\item При помощи диспетчера процессов делаются необходимые изменения в блоке управления потоком.
	\item Поток запускается на выполнение.
\end{enumerate}
\section{Процессы и потоки в Windows.}
\setcounter{subsection}{0}
\subsection{Процессы в Windows}
Диспетчер процессов управляет созданием и удалением процессов, а также отношениями между ними: родительский - дочерний процессы. Таким образом определяется древовидная структура процессов.\\
Особенности процессов Windows:
\begin{itemize}
        \item Процессы реализованы как объекты, и доступ к ним осуществляется посредством объектных сервисов (по принципу ООП).
	\item В адресном пространстве процесса может исполняться несколько потоков.
	\item Объект процесс и объект поток имеют встроенные возможности синхронизации.
\end{itemize}
Процесс состоит из:
\begin{itemize}
        \item Исполняемой программы (код и данные).
	\item Закрытого адресного пространства, т.е. набора адресов виртуальной памяти, который процесс может использовать.
	\item Системных ресурсов, выделяемых операционной системой процессу во время выполнения программы (семафоров, файлов и т.д.).
	\item По крайней мере одного потока управления.
	\item Блока управления процессом (Process Control Block).
\end{itemize}
\begin{center}
	\includegraphics[scale=0.3]{14}
\end{center}
\subsection{Потоки в Windows}
\textbf{Поток} - это единица исполнения, отдельный счётчик команд или подлежащая планированию сущность внутри процесса. В то время как процесс - это логическое представление работы, которую должна выполнить программа, поток отображает одну из многих необходимых подзадач.\\
Блок управления потоком:
\begin{itemize}
        \item Уникальный идентификатор.
	\item Содержимое набора регистров, отражающее состояние процессора.
	\item Два стека: один используется потоком при работе в пользовательском режиме, а другой - в режиме ядра.
	\item Собственная область памяти, предназначенная для использования библиотеками (Run-time Library. Dynamic Link Library).
\end{itemize}
\textbf{Run-time Library (библиотека времени выполнения)} - специальная программная библиотека, используемая компилятором для реализации функций, встроенных в ЯП, во время выполнения компьютерной программы. В эти библиотеки входят функции ввода и вывода, управления паматью или математические функции.\\
\textbf{Run-time Library (RTL)} можно внедрять в программу, но при этом увеличивается размер программы. RTL можно устанавливать в JC и вызывать при выполнении программы. Обширный набор RTL образует среду выполнения, устнавливаемую поверх ОС.\\
Содержимое регистров, стека и собственной области памяти называется контекстом потока.\\
Поток находится в адресном пространстве процесса, используя его для хранения данных во время выполнения. Если в одном процессе существует несколько потоков, то они совместно используют адресное пространство и все ресурсы, включая маркер доступа, базовый приоритет и описатели объектов из таблицы объектов процесса.
\subsection{Динамический приоритет потоков Windows}
Для выбора порядка в котором исполняются потоки, ядро NT использует приоритеты. Windows динамически повышает приоритет некоторых потоков для оптимизации общей пропускной способности и отзывчивости системы в следующих случаях:
\begin{enumerate}
        \item При переводе потока в состояние ожидание ввода/вывода приоритет потока повышается на 2. После разблокирования потока и запуска его на выполнение, в течение одного кванта поток выполняется с этим приоритетом. После этого приоритет уменьшается на один уровень. После выполнения в течение ещё одного кванта приоритет уменьшается ещё на 1.
	\item При выводе окна на передний план приоритет потока, отвечающего за это окно повышается на 2. При переводе окна в фон приоритет окна снижается на 2.
	\item По окончании ожидания на каком-либо объекте исполнительной системы приоритет потока увеличивается на один уровень. После разблокирования потока и запуска его на выполнение, в течение одного кванта поток выполняется с этим приоритетом. После этого приоритет уменьшается на один уровень.
	\item Периодически планировщик сканирует очереди готовых потоков и ищет потоки, которые находились в состоянии \textbf{Ready} более 3 секунд. Обнаружив такой поток, диспетчер повышает его приоритет до 15 и выделяет ему квант вдвое больше обычного. По истечении двух квантов приоритет потока снижается до исходного уровня. 
\end{enumerate}
\subsection{Достоинства и недостатки многопоточного программирования}
Достоинства:
\begin{itemize}
        \item Ускорение вычислений за счёт распараллеливания вычислительных операций.
	\item Повышение комфорта работы пользователя с программой за счёт разделения разных операций по потокам и повышения приоритета у того потока, который отвечает за взаимодействие с пользователем..
	\item Быстрое создание потоков по сравнению с созданием процессов.
	\item По сравнению с многопроцессными приложениями экономится память за счёт совместного использования памяти несколькими потоками.
	\item Простой и быстрый обмен данными между потоками (по сравнению с обменом данными между процессами).
\end{itemize}
Недостатки
\begin{itemize}
        \item В большинстве случаев невозможно разпараллелить данные для проведения параллельных вычислений.
	\item Сложность программирования многопоточных приложений из-за необходимости синхронизцаии работы потоков.
	\item Многопоточные приложения требуют больше оперативной (не виртуальной) памяти по сравнению с однопоточными.
\end{itemize}
\section{Операционные системы семейства UNIX/Linux}
\setcounter{subsection}{0}
Операционная система UNIX относится к категории многопользовательских многопрограммных ОС, работающих в режиме разделения времени. На основе UNIX создана ОС Linux. На основе Linux - ОС Android. Сущевствует множество разновидностей UNIX и Linux.\\
UNIX - FreeBSD, OpenBSD, Solaris.\\
Linux - Ubuntu, CentOS, Fedora, openSUSE.
Для того, чтобы унифицировать API используется стандарт \textbf{POSIX} (Portable Operating System Interface for UNIX).
\textbf{POSIX} - набор стандартов описывающих интерфейсы между операционной системой и прикладной программой (системный API), библиотеку языка C и набор приложений и их интерфейсов. Стандарт создан для обеспечения совместимости различных UNIX-подобных операционных систем переносимости прикладных программ на уровне исходного кода, но может быть использован и для не-UNIX систем. 
\subsection{Архитектура Linux}
\begin{center}
        \includegraphics[scale=0.3]{15}
\end{center}
\textbf{Демон}  - это системная служба, выполняющая определённую функцию. Как правило демоны запускаются в процессе старта операционной системы.\\
\textbf{Системные утилиты} предоставляют пользователю определённые сервисные функции. Вызываются по мере необходимости. 
\begin{center}
	\includegraphics[scale=0.3]{16}
\end{center}
Ядро ОС UNIX состоит из двух основных частей: управления процессами и управления устройствами. Управление процессами резервирует ресурсы, определяет последовательность выполнения процессов и принимает запросы на обслуживание. Управление устройствами контролирует передачу данных между оперативной памятью и периферийными устройствами.\\
\textbf{Символьные устройства} обрабатывают данные последовательно посимвольно. Произвольный доступ к данным невозможен.\\
\textbf{Блочное устройство} хранит и обрабатывает информацию отдельными блоками. Используется произвольный доступ к данным, хранящимся в блоках.\\
Пользователь взаимодействует с компьютером через один или несколько терминалов. Управляет терминалами \textbf{X Windowing System}.\\
Один из этих терминалов имеет графический интерфейс. Наиболее известные графические оболочки GNOME, KDE и другие.\\
В текстовых терминалах можно использовать различные командные интерпретаторы. Наиболее известные: bash, tcsh, zsh.
\subsection{Процессы в Linux}
Организация работ в ОС Linux основана на понятии \textbf{процесса как единицы работы, управления и потребления ресурсов}. Взаимодействие процессов с ядром происходит по принципу сопрограмм, т.е. процесс системных функций и ядра используется API.\\
\begin{center}
	\includegraphics[scale=0.3]{17}
\end{center}
\begin{center}
	Разделы памяти.
\end{center}
\textbf{TEXT} - программный код. Доступ к этому участку памяти только для чтения.\\
\textbf{DATA} - данные программы. Данные можно изменять, хотя  могут быть данные только для чтения.\\
\textbf{STACK} - стек нужен для организации функциональных блочных вычислений. При вызове подпрограммы в стеке запоминается адрес основной программы, откуда производился вызов, и содержимое регистров процессора. При вызове подпрограммы из вызванной подпрограммы запоминается аналогичная информация. После завершения работы подпрограммы из стека извлекается адрес памяти, откуда надо продолжить выполнение программы.\\
\textbf{HEAP} - куча. Динамические данные программы, под которые выделяется память.\\
Программа фактически состоит из двух частей: самой программы, находящейся в исполняемом файле, и библиотек, которые требуются для выполнения программы. Библиотеки загружаются двумя способами.\\
При запуске исполняемого файла. Это происходит, когда библиотека обязательно потребуется при работе программы.\\
Программа в процессе выполнения может потребовать загрузить библиотеку. Это происходит тогда, когда библиотека нужна только при выполнении некоторых необязательных операций.\\
В Linux, как правило, одна библиотека зависит от другой, и одна программа может зависеть от другой.\\
\subsection{Потоки в Linux}
\textbf{Легковесные (лёгкие) процессы} - это аналог потоков в Windows. Они создаются для совместного использования адресного пространства. Такие легковесные процессы образуют группу процессов.\\
Программа на стадии выполнения называется \textbf{заданием}. Задание может содержать несколько процессов, образующих группу процессов.\\
Группы нумеруются по ID первого созданного процесса. Даже если процесс завершает свою работу, то ID группы не меняется.\\
\subsection{Планирование в Linux}
В UNIX также используется приоритетный метод планирования выполнения процессов. Приоритет называется \textbf{nice} (любезность). В отличие от Windows в UNIX чем выше число тем ниже приоритет. Всего 40 уровней приоритета от -19 до 20.\\
По умолчанию процесс получает значение 0. Дочерний процесс наследует приоритет родительского.\\
Используя специальные команды, можно устанавливать приоритет запускаемой программы или изменять приоритет уже запущенной программы.\\
\textbf{nice} - запуск программы с определённым приоритетом.\\
\textbf{renice} - изменение приоритета уже запущенной программы.\\ 
\subsection{Рождение и завершение процесса в Linux}
В UNIX рождение процесса происходит путём дублирования родительского процесса. В результате у дочернего процесса пользовательский контекст такой же как и у родительского процесса. 
\begin{center}
	\includegraphics[scale=0.3]{18}
\end{center}
Для замены контекста используется специальная команда ОС. В результате выполнения этой команды происходит загрузка в память исполняемого файла и библиотек. После этого процесс переходит в состояние готовность.\\
\textbf{fork} - создание обычного процесса.\\
\textbf{clone} - создание легковесного процесса. Не создаются копии адресного пространства родительского процесса. Потоки используют совместно адресное пространство вместе с другими ресурсами, включая дескрипторы файлов.\\
\textbf{exec} - загрузка программы в адресное пространство процесса.\\ 
\begin{center}
	\includegraphics[scale=0.3]{19}
\end{center}
\subsection{Псевдофайловая система}
В Windows используется объектная модель, а в Linux - файловая. Все сущности в Linux представляются файлами. В ОС Linux/UNIX используется шесть типов файлов:
\begin{itemize}
        \item \textbf{Обычный файл} - именованная область на внешнем носителе. Обычные файлы содержат данные пользователей.
	\item \textbf{Символьная ссылка} - содержит путь к некоторому файлу.
	\item \textbf{Каталог} - это файл, содержащий информацию о файлах и других каталогах, находящийся внутри каталога. Каталоги используются системой для поддержания файловой структуры.
	\item \textbf{FIFO файлы (First Input - First Output} - используются для обмена данными между процессами. Данные передаются через ядро, при этом создаётся именованный канал Named Pipe.
	\item \textbf{Файл сокет (Socket)} - тоже используется для межпроцессного взаимодействия, но именованные каналы не создаются, создаются сокеты. Сокеты можно адресовать по IP адресу и номеру порта. Через один файл-сокет могут передавать данные несколько процессов. 
\end{itemize}
\end{document}


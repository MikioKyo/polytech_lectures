\documentclass[a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}
\usepackage[russian]{babel}
\usepackage{graphicx}
\usepackage{url}
\graphicspath{ {pictures/} }
\begin{document}
\begin{center}
	Конспект лекций по операционным системам.
\end{center}
\section*{Базовые определения}
Прикладное ПО - это программы, выполняющие задачи, требуемые пользователю\\
Системное ПО - это программы, способствующие функционированию прикладных программ и упрощающие их разработку\\
Системное ПО - это операционные системы, драйверы и фреймворки\\
Драйвер - программа, управляющая работой периферийного устройства\\
Операционная система - это программа, обеспечивающая среду выполнения для других программ и облегчающая им доступ к устройствам, составляющим компьютер, процессору, жёсткому диску и т.д.  \\
Фреймворк - это программная среда специального назначения, используемая для того, чтобы упростить написание программ и облегчить объединение отдельных программных компонентов.\\
\section*{Услуги, предоставляемые ОС}
Упрощают использование аппаратных средств. Создаваемая ими виртуальная машина заметно отличается от реальной. ОС изолируют пользователей от аппаратной части компьютеров.\\
ОС обеспечивает распределение вычислительных ресурсов между программами.\\
Управляет файлами и папками. Для упрощения работы пользователей создаётся файловая система.\\
Предоставляет пользователю интерфейс для взаимодействия с программами и компьютером.\\
\section*{Интерфейс}
Интерфейс - набор средств, используемые для взаимодействия двух систем.\\
\section*{Типы интерфейсов}
Графический интерфейс. Управление осуществляется путём нажатия на различные виды кнопок, которые изображены на экране. \\
Интерфейс командной строки. Управление осуществляется путём набора текстовых команд.\\
Программный интерфейс. Через программный интерфейс программы взаимодействуют друг с другом. API - Application Programming Interface.\\
Голосовой интерфейс - команды даются с помощью голоса, речи.\\
Жестовый интерес - управление с помощью жестов: сенсорный экран, тачпад, джойстик, руль \\
Нейрокомпьютерный интерфейс - обмен данными между человеческим мозгом и электронным устройством осуществляется с помощью биологической обратной связи и встроенных электронных имплантов.\\
Аппаратный - предназначений для взаимодействия физических устройств друг с другом: тип разъёмов и параметры сигналов передаваемых через эти разъёмы.\\
\section*{Задание. Процесс.}
Задание - совокупности программы и входных данных, необходимых для её выполнения. \\
Процесс - экземпляр программы во время выполнения, независимый объект, которому выделены системные ресурсы, например, процессорное время и память. Каждый процесс выполняется в отдельном адресном пространстве. Один процесс не может получить доступ к данным другого процесса.\\
Понятие процесса включает:\\
1. Множество внешней по отношению к процессу информации, используемой ОС для управления ресурсом типа «процесс». Состав данной информации зависит от ОС.\\
2. Структура и содержимое адресного пространства процесса. Т.е. части памяти, выделенной процессу.\\
3. Множество ресурсов, принадлежащих процессу или используемых процессом, а также состояние этих ресурсов.\\
\section*{Архитектура ОС}
\setcounter{section}{1}
\subsection{Монолитная ОС}%
\setcounter{subsection}{1}
В монолитной ОС система организуется как набор процедур, каждую из которых может вызывать пользовательская программа. Вся ОС расположена в едином адресном пространстве. \\
Пользовательский режим - процесс не может получить доступ к чужой области памяти, не все инструкции процессора ему доступны. Поток, исполняющийся в пользовательском режиме, может получить доступ к системным ресурсам только посредством вызова системных сервисов. Когда программа пользовательского режима вызывает системный сервис, вызов перехватывается и вызывающий процесс переключается в режим ядра.\\
Режим ядра - привилегированный режим работы процессора, в котором исполняется код ОС. Поток, исполняющийся в режиме ядра, имеет доступ ко всей памяти и аппаратуре.\\
Системные сервисы - набор программ, которые перехватывают обращение прикладных программ к системным ресурсам. Когда выполнение системного сервиса завершается, ОС переключает поток обратно в пользовательский режим.\\
Привилегия - это свойство, устанавливаемое при проектировании системы, которое определяет, какие компьютерные операции разрешены, какие доступы к памяти законны. Привилегии испльзуются для обеспечения безопасности в компьютерной системе и повышения надёжности её работы.\\
Привилегии реализуются путём присвоения процессам значения от 0 до 3. Значение 0 соответствует наибольшим привилегиям, тогда как значение 3 - наименьшим.\\
Привилегии реализуются на уровне процессора.\\
\begin{center}
Достоинства монолитной ОС
\end{center}
1. Высокая скорость\\
2. Относительно простая разработка ОС:\\
\begin{center}
Недостатки:
\end{center}
1. Поскольку всё ядро работает в одном адресном пространстве, сбой в одном из компонентов может нарушить работоспособность всей системы.\\
2. Усовершенствование ОС затруднено, т.к. внесение изменений в одну часть ОС может потребовать внесение изменений в другие части ОС.\\
Примеры монолитных ОС: MS DOS, первые версии MacOS\\
\subsection{Модульная операционная система}
\setcounter{2}\\
Модульная ОС - это ОС, в которой каждый программный модуль (часть ОС) имеет законченное функциональное назначение с оговорёнными правилами взаимодействия. Все модули ОС равнозначны. В отличие от монолитной ОС, каждому модулю выделена своя область памяти. Все модули исполняются в режиме ядра.\\
\begin{center}
	Достоинства модульной ОС:
\end{center}
1. Упрощается усовершенствование ОС\\
2. Достаточно высокая надёжность ОС, т.к. сбой в одном модуле не влияет на другие\\
\begin{center}
	Недостатки модульной ОС:
\end{center}
1. Усложняется создание ОС\\
Модульную архитектуру имеет разновидность UNIX - FreeBSD.
Linux имеет монолитно-модульную архитектуру.
\subsection{Послойная ОС}
Достоинства:\\
1. упрощается усовершенствование ОС\\
2. Достаточно высокая надёжность ОС\\
Недостатки:\\
1. Уменьшение быстродействия ОС.\\
Частично послойную архитектуру имеет ОС Windows.
\subsection{Микроядерные ОС}
В сложном программном продукте в среднем содержится 10 ошибок на 1000 строк кода. Следовательно, монолитная операционная ОС, состоящая из 5000000 строк кода, скорее всего, содержит от 10000 до 50000 ошибок. Таким образом, для уменьшения количества ошибок надо уменьшать размер кода, работающего в привилегированном режиме.\\
MacOS X использует микроядерную архитектуру, которая основана на микроядре Mach. При этом используются некоторые модули, взятые из ОС FreeBSD.\\
Harmony OS - микроядерная ОС, устанавливается на смартфоны компании Huawei.\\
Микроядро MINIX 3 занимает всего лишь около 12000 строк кода на языке C и 1400 строк кода на ассемблере.\\
\begin{center}
	Достоинства микроядерной ОС:
\end{center}
1. Достаточно высокое быстродействие\\
2. Высокая надёжность. Микроядерную архитектуру используют ОС, работающие в реальном масштабе времени в промышленных устройствах, авиации и военной технике.\\
\begin{center}
	Недостатки микроядерной ОС:
\end{center}
1. Сложность разработки\\
2. При увеличении числа процессов значительно падает быстродействие, т.к. увеличивается число обращений к ядру.
\subsection{Клиент-серверная ОС}
Клиент-серверная ОС разделяет процессы на два типа:\\
1. Процесс сервера, каждый из которых предоставляет какую-нибудь службу\\
2. Процесс клиента, который пользуется этими службами.\\
Для свзяи клиентов с серверами используется ядро (микроядро).\\
Связь между клиентами и серверами организуется с помощью передачи сообщений следующим образом:\\
1. Клиентский процесс составляет сообщение, в котором говорится, что именно ему нужно, и отправляет его ядру или микроядру.\\
2. Ядро или микроядро ОС определяет, какой сервер должен ответить на сообщение, и доставляет сообщение серверу.\\
3. Служба выполняет определённую работу и отправляет обратно ответ.\\
4. Ядро возвращает клиенту результат в виде другого сообщения.\\
\section*{Требования к ОС}
\setcounter{section}{2}
Требования правительства США.
\subsection{Совместимость с POSIX}%
\setcounter{subsection}{6}
Lorem Ipsum
\subsection{Безопасность}%
\setcounter{subsection}{7}
Безопасность, то есть защита от несанкционированного доступа. Требования, выполнение которых делает систему многопользовательской.\\
А. Защита от несакционированного проникновения на компьютер.\\
Б. Защита ресурсов пользователя от других пользователей.\\
В. Возможность установления квот на системные ресурсы для предотвращения захвата одним пользователем всех системных ресурсов.\\
Г. Разграничение прав доступа пользователей к файлам и устройствам.\\
Д. Сохранение информации о действиях пользователей, связанных с безопасностью.\\
\section*{Особенности реализации ОС Windows}
\setcounter{section}{3}
\setcounter{subsection}{0}
\begin{center}	
	\includegraphics[scale=0.3]{1}
\end{center}
Ядро (kernel) - компонент операционной системы, непосредственно взаимодействующий с процессом и памятью. Выполняет планирование и переключение потоком, обработку прерываний и исключений, взаимодействие с драйверами и мультипроцессорную синхронизацию.\\
В Windows также реализована идея помещать в ядро исполнительный механизм, а не политику.\\
\subsection{Поток}%
В Windown - процесс не является испольняемой сущностью, т.е. непосредственно не выполняется процессором. Это некий объект, который характеризует задачу во время испольнения.\\
Исполняемая сущность внутри процесса - это поток выполнения (thread of execution).\\
Поток - это программа, выполняющаяся в адресном пространстве процесса и имеющая доступ ко всем ресурсам процесса. Каждый процесс должен содержать не менее одного потока. Как правило, в Windows процесс содержит несколько потоков.\\
Поток - это способ распараллеливания вычислительных операций и экономии памяти.\\
В то время как процесс - это логическое предстваление работы, которую должна выполнить программа, поток отображает одну из многих необходимых подзадач.\\
\subsection{Прерывания}
Прерывания (interrupt) - это запрос, поступающий от устройства ввода-вывода, исполняющейся программы или процессора с требованием прервать выполнение текущей программы и запустить на выполнение другую программу. Прерывания бывают внешние и внутренние.\\
Внешние прерывания являются внешними по отношению к процессору, поэтому так и называются. Внешние прерывания бывают друх типов: прерывания ввода-вывода и аппаратные прерывания.\\
Прерывания ввода-вывода создают переферийные устройства, которые сообщают, что они готовы выполнить операцию ввода или вывода. Для выполнения операции ввода-вывода надо прервать выполнение текущей программы и выполнить программу управления вводом-выводом. Программа, вызываемая при возникновении прерывания называется программонй обработки прерывания.\\
Аппаратные прерывания поступают в процессор от различных устройств компьютера и не связаны с вводом-выводом. Они сигнализируют о наступлении какого-нибудь события или об обнаружении сбоев в работе какого-нибудь устройства. В этом случае тоже вызывается соответсвтующая программа обработки прерывания.\\
Внутренние прерывания происходят внутри процессора и бывают двух типов:\\
Программными прерываниями считаются запросы со стороны программы на начало выполнения операции ввода-вывода или при обращении к функциям операционной системы.\\
Исключительные ситуации (исключения) возникают в тех случаях, когда процессор не в состоянии выполнить предусмотренное в программе действие, например, деление на ноль. В этом случае он прерывает выполнение программы и сообщает операционной системе о наличии исключительной ситуации, а также выдаёт необходимую дополнительную информацию, которая позволяет более точно определить причину её возникновения.\\
\begin{center}	
	Исключительные ситуации бывают следующих типов:\\
\end{center}
Деление на ноль\\
Пошаговая работа (трассировка)\\
Переполнение порядка при работе со знаковым операндом\\
Выход индекса за границу, т.е. обращение к области памяти не принадлежащей к данной программе. В этом случае выдаётся ошибка General Protection Fault. (Нарушения основной защиты)\\
Другие исключительные ситуации\\
\subsection{Уровень абстрагирования от оборудования}
Ядро осуществляет взаимодействие с устройствами, но не непосредственно, а через уровень абстрагирования от оборудования. Чтобы работа ядра не зависела от аппаратного обеспечения введён слой абстрагирования от оборудования HAL (Hardware Abstraction Layer).\\
В HAL входит загружаемый модуль режима ядра (\url{C:\Windows\System32\hal.dll}, предоставляющий низкоуровневый интерфейс с аппаратной платформой, на которой выполняется Windows. Он скрывает от ОС специфику конкретной аппаратной платформы, т.е. все функции, зависимые от архитектуры и от конкретной машины. Таким образом, ядро работает с некоей стандартизированной виртуальной машиной. HAL преобразует команды ядра в команды, понятные конкретному оборудованию.\\
Также в HAL входят драйверы различных переферийных устройств.\\
DLL (Dynamic Link Library) - динамически подключаемая библиотека, подпрограмма, позволяющая многократное использование различными программными приложениями. К DLL относятся разные программные компоненты и в частности драйверы.\\
В системах UNIX также используются библиотеки. Они имеют расширение .so (shared object).\\
\subsection{Исполнительная система}
Исполнительная система (executive system) - спроектирована как уровень абстрагирования от ядра. Она обеспечивает специфические политики для управления объектами, памятью, процессами, файлами и устройствами. Таким образом, ядро реализует механизм, а исполнительная система - политику.\\
Ядро и исполнительная система включаются в один исполняемый модуль NTOSKRNL.EXE.
\begin{center}
	\includegraphics[scale=0.3]{2}
\end{center}
\begin{center}
Основные модули исполнительной системы:
\end{center}
1. Диспетчер объектов (Object Manager).\\
2. Диспетчер процессов и потоков (Process and Thread Manager).\\
3. Диспетчер виртуальной памяти (Virtual Memory Manager).\\
4. Справочный монитор защиты (Security Reference Monitor).\\
5. Диспетчер ввода-вывода (I/O Manager).\\
6. Диспетчер кэша (Cache Manager).\\
7. Средство локального вызова процедур (Local Procedure Call).\\
\subsection{Подсистема}
Подсистема - это программный модуль, который выступает в качестве сервера. При помощи подсистем реализуется клиент-серверная архитектура.
\begin{center}
	\includegraphics[scale=0.3]{3}
\end{center}
\begin{center}
	\includegraphics[scale=0.3]{4}
\end{center}
\subsection{Приоритеты Windows}
В Windows используется приоритетный, с вытеснением и кватованием времени планировщик.\\
Процессор выделяется потоку на квант времени, вычисляемый, как несколько тиков системных часов. Планировщик поддерживает 32 уровня приоритета и соответственно столько же различных очередей планировщика.\\
Алгоритм работы планировщика такой:\\
\begin{itemize}	
\item В соответствии с приоритетом выполнения потоков создаётся несколько очередей. В каждой очереди потоки только с одинаковым приоритетом.\\
\item Сначала выполняются потоки из очереди с самым высоким приоритетом.\\
\item Если в этой очереди нет больше потоков, тогда планировщик будет обслуживать очередь второго по величине приоритета, потом третьего и т.д.\\
\end{itemize}
\begin{center}
	\includegraphics[scale=0.3]{5}
\end{center}
Самый высокий приоритет у потоков реального времени, он больше чем у потоков ОС. Такой приоритет нужен для обработки высокоскоростных потоков данных, которые нужно обрабатывать в реальном времени.\\
На динамическом уровне выполняются почти все прикладные системные процессы. Особенностью данного уровня является то, что приоритеты потоков могут меняться в течение времени в зависимости от ситуации и действий пользователя. Приоритет повышается для тех потоков, с которыми непосредственно в данный момент работает пользователь.\\
Системный уровень предназначен для одного системного процесса Idle. Этот процесс обладает самым низким приоритетом и работает, когда процессор простаивает. Процесс Idle удаляет ненужные данные из файла подкачки, также снижает энергопотребление процессора при простое. На каждом ядре процессора запускается по одному потоку процесса Idle.\\
\begin{center}
	\includegraphics[scale=0.3]{6}
\end{center}
Приоритеты процессов могут принимать не все возможные значения от 0 до 31, а только несколько определённых значений.\\
\begin{itemize}
	\item Real Time Class (значение 14)
	\item High Class (значение 13)
	\item Above Normal class (значение 10)
	\item Normal Class (значение 8)
	\item Below Normal Class (значение 6)
	\item Idle Class (значение 4)
\end{itemize}
По умолчанию приоритет процесса наследуется от родительского процесса следующим образом:\\
\begin{itemize}
	\item Если приоритет родительского процесса Normal или ниже, то дочерний процесс имеет приоритет равный родительскому
	\item Если приоритет родительского процесса выше Normal, то дочерний процесс имеет приоритет Normal.
\end{itemize}
Приоритет потока - величина, складывающаяся из двух составных частей: приоритета породившего поток процесса и собственно приоритета потока.\\
Приоритет потока задаётся относительно приоритета процесса.
\begin{itemize}
	\item Normal: такой же какой и у процессора
	\item Above normal: +1 к приоритету процесса
	\item Below normal: -1;
	\item Highest: +2;
	\item Lowest: -2;
	\item Time critical: устанавливает базовый приоритет потока для Real Time в 31, для остальных классов в 15;
	\item Idle: устанавливает базовый приоритет потока для Real Time класса в 16, для остальных классов в 1.
\end{itemize}
\begin{center}
	Зависимость приоритета потока от приоритета процесса.\\
	\includegraphics[scale=0.3]{7}
\end{center}
Многопоточность приложений нужна для следующих целей:\\
Распараллеливания вычислений для ускорения работы программы за счёт того, что разные потоки выполняются на разных ядрах.\\
Задания разным потокам разных приортетов для повышения удобства работы пользователя с программой. Таким образом базовый (начальный приоритет потока определяется процессом, но ОС может его менять для удобства работы пользвователя с программой. Когда пользователь непосредственно взаимодействует с потоком ОС повышает приоритет потока. Если пользователь перестаёт взаимодействовать с этим потоком, то приоритет понижается.\\
\subsection{Изменение приоритетов}
Используя системные функции Windows, программист может задать приоритет процесса при его создании и в дальнейшем при необходимости изменить.\\
Для создания процесса используется системная функция CreateProcess. Эта функция позволяет задать класс приоритета создаваемого процесса.\\
Приоритет процесса можно изменить и после его создания, используя функцию SetPriorityClass.\\
Команда Start позволяет создать процесс и задать его приоритет.\\
Пользователь получает доступ к функции SetPriorityClass, используя специальные утилиты, например, диспетчер задач и Process Explorer.\\
Изменение приоритетов индивидуальных потоков внутри процесса обычно не имеет смысла, так как программист определил приоритеты потоков в соответствии с логикой работы программы. Изменение относительных приоритетов потоков может привести к неадекватному поведения приложения.\\
\section*{Кеш-память}
\setcounter{subsection}{0}
Кэш-память - это промежуточная память которая сглаживает разницу в быстродействии основных видом памяти. Использование кэш-памяти значительно ускоряет обмен данными между устройствами.\\
\begin{center}
	\includegraphics[scale=0.3]{8}
\end{center}
Экспериментально установлено, что после обработки некоторых данных процессор с большой вероятностью обращается к тем же самым данным или к данным, находящимся в непосредственной близости от них. Это явление называется принципом пространственной локализации.\\
Также установлено, что программе в ближайшее время, вероятнее всего, потребуются данные, которые использовались недавно. Эта закономерность называется принципом временной локализации.\\
Эти два принципа используются для ускорения обмена данными с дисковыми накопителями.\\
При чтении данных с диска читаются не только требуемые данные, но и данные находящиеся рядом, т.е. читается не один блок данных, а несколько. Прочитанные данные автоматически заносятся в кэш. Эта процедура называется упреждающее чтение.\\
Перед чтением данных с жёсткого диска выполняется попытка чтения данных из кэша. Если нужные данные действительно находятся в кеше, то они с высокой скоростью записываются в основную часть оперативной памяти, не относящейся к кешу. Эта ситуация носит название попадание в кеш. Если данные в кеше отсутствуют, то говорят, что имеет место промах кеша, и данные читаются с диска.\\
Если кеш заполнен полность, то при записи новых данных удаляются те данные, которые записаны давно и продолжительное время не использовались\\
Такое накопление данных называется кешированием.\\
При записи данных на диск сначала происходит запись в кеш. Существует 3 способа записи на диск:\\
\begin{enumerate}
        
	\item Прямая запись - данные из кеша сразу записываются на жёсткий диск. Это самый надёжный, но самый медленный вариант.\\
\item Обратная запись - данные из кеша записываются на жёсткий диск в первом же свободном такте работы процессора. Эта схема использует некоторую задержку во времени относительно момента записи в кеш. Благодаря этому она более эффективна, чем схема прямой записи.\\
\item Отложенная запись - запись на жёсткий диск выполняется только при окончательном заполнении кеша, то есть когда для помещения в кеш нового значения не оказывается свободной области.\\
\end{enumerate}
Использование кеш-памяти уменьшает количество обращений к жёсткому диску. Благодаря этому происходит ускорение обмена данными с дисковыми накопителями.\\
Обратная и отложенная запись значительно ускоряют работу с дисковыми накопителями, но существует риск потери данных при отключении питания компьютера или при потери связи с накопителем.\\
В Windows кэшем в оперативной памяти управляет соответствующий модуль в исполнительной системе - диспетчер кеша. Диспетчер кеша в частности определяет какая часть оперативной памяти выделяется под кеш.\\
\section{Виртуальная память}
\setcounter{subsection}{0}
Виртуальная память - метод управления памятью компьютера, позволяющий выполнять программы, требующие больше оперативной памяти, чем имеется в компьютере, путём автоматического перемещения частей программы между основной памятью и вторичным хранилищем, например, жёстким диском.\\
Достоинства использования виртуальной памяти:\\
\begin{itemize}
        \item Программа не ограничена объёмом физической оперативной памяти. Успрощается разработка программ, поскольку можно задействовать большие виртуальные пространства, не заботясь о размере используемой памяти.\\
        \item Поскольку появляется возможность частичного помещения программы (процесса) в память и гибкого перераспределения памяти между программами, можно разместить в памяти больше программ, что увеличивает загрузку процессора и пропускную способность системы.	
\end{itemize}
\subsection{Файл подкачки.}
Файл подкачки - это область на жёстком диске, которая повторяет структуру оперативной памяти и имеет такую же адресацию как оперативная память.\\
Файл подкачки можно назвать виртуальной памятью. Размер виртуальной памяти гораздо больше оперативной и ограничен только размером жёсткого диска и величиной адресного пространства процессора.\\
При запуске программы на выполнение создаётся процесс и этому процессу выделяется виртуальное адресное пространство. Таким образом, код и данные копируются сначала в виртуальную память, а потом по мере необходимости по частям копируются из виртуальной памяти в оперативную.\\
В Windows виртуальная память находится в фалй \url{pagefile.sys} или \url{swap.sys}. Этот файл называется файлом подкачки или своп-файлом. Размер этого файла обычно в 2 раза больше размера оперативной памяти.\\
В ОС Unix и Linux вместо файла подкачки используется раздел подкачки - область на жёстком диске, выделенная для виртуальной памяти.\\
В MacOS используется несколько файлов подкачки.\\
\url{/private/var/vm/swapfile0,.../swapfile1,.../swapfile2,...}\\
В операционных системах iOS и Android файла подкачки нет.\\
\subsection{Страничная организация памяти}
Для организации виртуальной памяти адресное пространство, подразделяется на блоки памяти 4 КБ или 4 МБ каждый. Такие блоки называются логическими страницами.\\
Фактически имеющаяся в компьютере оперативная память также делится на участки длиной 4 КБ или 4 МБ, которые называются страничными кадрами.\\
При объёме оперативной памяти 4ГБ образуется 1024 страничных кадра.\\
\begin{center}
        \includegraphics[scale=0.3]{9}
\end{center}
\begin{center}
        \includegraphics[scale=0.3]{10}
\end{center}
При любом обращении к памяти определяется, находится ли связанная с сегментом логическая страница в оперативной памяти. Если страница находится в памяти, то происходит прямое обращение к ней.\\
В противном случае нужная логическая страница автоматически загружается (подкачивается) операционной системой с жёсткого диска в один из неиспользуемых или редко используемых страничных кадров оперативной памяти.\\
Адрес в оперативной памяти отличаается от адреса в виртуальной памяти. Для доступа к нужной ячейке памяти нужно осуществить преобразование логического адреса в виртуальной памяти в физический адрес в оперативной памяти. Это преобразование осуществляется диспетчером виртуальной памяти.\\
\subsection{Адресация памяти}
Следует понимать разницу между возможностью адресации виртуальной памяти и возможностью адресации физической памяти. Адресация виртуальной памяти определяется типом процессора.\\
Максимальный размер адресуемой физической памяти зависит ещё и от операционной системы. Так 32-разрядная ОС Windows может адресовать не более 4ГБ физической памяти. Windows 10 x64 Home может адресовать 128 ГБ, остальные 64-х разрядные версии 2ТБ.
\subsection{Диспетчер виртуальной памяти.}
В Windows виртуальной памятью управляет диспетчер виртуальной памяти. Диспетчер виртуальной памяти выполняет следующие действия:
\begin{enumerate}
	\item Выделяет и освобождает виртуальное адресное пространство
        \item Обеспечивает своевременную подкачку данных из виртуальной памяти в физическую
	\item Обеспечивает отображение логических адресов виртуальной памяти в физические адреса оперативной памяти.
\end{enumerate}
\section{Диспетчер объектов}
\setcounter{subsection}{0}
Объектом является любая именованная составляющая компьютерной системы с которой работает ОС Windows за исключением процессора и памяти.\\
Диспетчер объектов управляет объектами и организует доступ процессов к объектам.
\begin{enumerate}
        \item Создаёт и удаляет объект
	\item Предоставляет доступ к объекту
	\item Изменяет информацию об объекте
\end{enumerate}
Объекты бывают двух видов:
\begin{enumerate}
        \item Объекты, отражающие реальные сущности, существующие в компьютерной системе: файлы, папки, принтеры и т.д.
	\item Объекты, не отражающие реальные сущности и необходимые для корректной работы процессов: семафоры, мьютексы и т.д.
\end{enumerate}
Если процессу нужен доступ к какому-нибудь объекту, то происходит обращение к диспетчеру объектов. Диспетчер объектов выполняет следующие действия:
\begin{enumerate}
        \item  Определяет существует ли требуемый объект
	\item Если объект не существует, то он создаётся
	\item  Для доступа процесса к объекту создаётся описатель объекта (handle). В Windows он называется дескриптор.
	\item Описатель возвращается процессу. 
\end{enumerate}
В дальнейшем при обращении к объекту прикладной процесс передаёт описатель соответствующей функции API, через которую происходит обращение к объекту.\\
Когда другой процесс попытается обратиться к уже существующему объекту, то диспетчер объектов создаёт второй описатель объёкта для этого процесса. Таким образом, число описателей в операционной системе гораздо больше числа объектов.
\end{document}

